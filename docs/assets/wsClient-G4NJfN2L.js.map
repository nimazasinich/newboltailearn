{"version":3,"file":"wsClient-G4NJfN2L.js","sources":["../../src/services/wsClient.ts"],"sourcesContent":["import { SystemMetrics } from './api'\nimport { WS_URL } from '../lib/config'\n\nexport type WSEventType = 'system_metrics' | 'training_progress' | 'training_complete'\n\nexport interface WSEvent {\n  type: WSEventType\n  data: any\n}\n\nexport type WSEventListener = (event: WSEvent) => void\n\nclass WSClient {\n  private ws: WebSocket | null = null\n  private url: string\n  private listeners = new Map<WSEventType, Set<WSEventListener>>()\n  private reconnectAttempts = 0\n  private maxReconnectAttempts = 5\n  private reconnectDelays = [1000, 2000, 5000, 10000, 10000] // 1s, 2s, 5s, 10s, 10s\n  private reconnectTimer: number | null = null\n  private isConnecting = false\n  private shouldReconnect = true\n\n  constructor(url?: string) {\n    this.url = url || WS_URL\n  }\n\n  connect(): Promise<void> {\n    if (this.isConnecting || (this.ws && this.ws.readyState === WebSocket.OPEN)) {\n      return Promise.resolve()\n    }\n\n    this.isConnecting = true\n    this.shouldReconnect = true\n\n    return new Promise((resolve, reject) => {\n      try {\n        this.ws = new WebSocket(this.url)\n\n        this.ws.onopen = () => {\n          console.log('[WS] Connected to WebSocket server')\n          this.isConnecting = false\n          this.reconnectAttempts = 0\n          if (this.reconnectTimer) {\n            clearTimeout(this.reconnectTimer)\n            this.reconnectTimer = null\n          }\n          resolve()\n        }\n\n        this.ws.onmessage = (event) => {\n          try {\n            const wsEvent: WSEvent = JSON.parse(event.data)\n            this.emit(wsEvent.type, wsEvent)\n          } catch (error) {\n            console.error('[WS] Failed to parse message:', error)\n          }\n        }\n\n        this.ws.onerror = (error) => {\n          console.error('[WS] WebSocket error:', error)\n          this.isConnecting = false\n          if (this.reconnectAttempts === 0) {\n            reject(new Error('Failed to connect to WebSocket server'))\n          }\n        }\n\n        this.ws.onclose = (event) => {\n          console.log(`[WS] Connection closed: ${event.code} ${event.reason}`)\n          this.isConnecting = false\n          this.ws = null\n\n          if (this.shouldReconnect && this.reconnectAttempts < this.maxReconnectAttempts) {\n            this.scheduleReconnect()\n          }\n        }\n      } catch (error) {\n        this.isConnecting = false\n        reject(error)\n      }\n    })\n  }\n\n  private scheduleReconnect() {\n    if (this.reconnectTimer) {\n      clearTimeout(this.reconnectTimer)\n    }\n\n    const delay = this.reconnectDelays[Math.min(this.reconnectAttempts, this.reconnectDelays.length - 1)]\n    console.log(`[WS] Scheduling reconnect in ${delay}ms (attempt ${this.reconnectAttempts + 1}/${this.maxReconnectAttempts})`)\n\n    this.reconnectTimer = setTimeout(() => {\n      this.reconnectAttempts++\n      this.connect().catch(error => {\n        console.error('[WS] Reconnect failed:', error)\n      })\n    }, delay)\n  }\n\n  disconnect() {\n    this.shouldReconnect = false\n    if (this.reconnectTimer) {\n      clearTimeout(this.reconnectTimer)\n      this.reconnectTimer = null\n    }\n    if (this.ws) {\n      this.ws.close(1000, 'Client disconnect')\n      this.ws = null\n    }\n  }\n\n  on(eventType: WSEventType, listener: WSEventListener) {\n    if (!this.listeners.has(eventType)) {\n      this.listeners.set(eventType, new Set())\n    }\n    this.listeners.get(eventType)!.add(listener)\n  }\n\n  off(eventType: WSEventType, listener: WSEventListener) {\n    const listeners = this.listeners.get(eventType)\n    if (listeners) {\n      listeners.delete(listener)\n      if (listeners.size === 0) {\n        this.listeners.delete(eventType)\n      }\n    }\n  }\n\n  private emit(eventType: WSEventType, event: WSEvent) {\n    const listeners = this.listeners.get(eventType)\n    if (listeners) {\n      listeners.forEach(listener => {\n        try {\n          listener(event)\n        } catch (error) {\n          console.error(`[WS] Error in event listener for ${eventType}:`, error)\n        }\n      })\n    }\n  }\n\n  get isConnected(): boolean {\n    return this.ws?.readyState === WebSocket.OPEN\n  }\n\n  get connectionState(): string {\n    if (!this.ws) return 'disconnected'\n    switch (this.ws.readyState) {\n      case WebSocket.CONNECTING: return 'connecting'\n      case WebSocket.OPEN: return 'connected'\n      case WebSocket.CLOSING: return 'closing'\n      case WebSocket.CLOSED: return 'closed'\n      default: return 'unknown'\n    }\n  }\n}\n\n// Export a singleton instance\nexport const wsClient = new WSClient()\n\n// Auto-connect when module loads\nwsClient.connect().catch(error => {\n  console.warn('[WS] Initial connection failed, will retry:', error.message)\n})\n\nexport default wsClient"],"names":["WSClient","url","__publicField","WS_URL","resolve","reject","event","wsEvent","error","delay","eventType","listener","listeners","_a","wsClient"],"mappings":"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"}