{"version":3,"file":"wsClient-a4670a49.js","sources":["../../src/services/wsClient.ts"],"sourcesContent":["import { SystemMetrics } from './api'\nimport { WS_URL } from '../lib/config'\n\nexport type WSEventType = 'system_metrics' | 'training_progress' | 'training_complete' | 'log_update' | 'training_error'\n\nexport interface WSEvent {\n  type: WSEventType\n  data: any\n}\n\nexport type WSEventListener = (event: WSEvent) => void\n\nclass WSClient {\n  private ws: WebSocket | null = null\n  private url: string\n  private listeners = new Map<WSEventType, Set<WSEventListener>>()\n  private reconnectAttempts = 0\n  private maxReconnectAttempts = 5\n  private reconnectDelays = [1000, 2000, 5000, 10000, 10000] // 1s, 2s, 5s, 10s, 10s\n  private reconnectTimer: ReturnType<typeof setTimeout> | null = null\n  private isConnecting = false\n  private shouldReconnect = true\n\n  constructor(url?: string) {\n    this.url = url || WS_URL\n  }\n\n  connect(): Promise<void> {\n    if (this.isConnecting || (this.ws && this.ws.readyState === WebSocket.OPEN)) {\n      return Promise.resolve()\n    }\n\n    this.isConnecting = true\n    this.shouldReconnect = true\n\n    return new Promise((resolve, reject) => {\n      try {\n        this.ws = new WebSocket(this.url)\n\n        this.ws.onopen = () => {\n          console.log('[WS] Connected to WebSocket server')\n          this.isConnecting = false\n          this.reconnectAttempts = 0\n          if (this.reconnectTimer) {\n            clearTimeout(this.reconnectTimer)\n            this.reconnectTimer = null\n          }\n          resolve()\n        }\n\n        this.ws.onmessage = (event) => {\n          try {\n            const wsEvent: WSEvent = JSON.parse(event.data)\n            this.emit(wsEvent.type, wsEvent)\n          } catch (error) {\n            console.error('[WS] Failed to parse message:', error)\n          }\n        }\n\n        this.ws.onerror = (error) => {\n          console.error('[WS] WebSocket error:', error)\n          this.isConnecting = false\n          if (this.reconnectAttempts === 0) {\n            reject(new Error('Failed to connect to WebSocket server'))\n          }\n        }\n\n        this.ws.onclose = (event) => {\n          console.log(`[WS] Connection closed: ${event.code} ${event.reason}`)\n          this.isConnecting = false\n          this.ws = null\n\n          if (this.shouldReconnect && this.reconnectAttempts < this.maxReconnectAttempts) {\n            this.scheduleReconnect()\n          }\n        }\n      } catch (error) {\n        this.isConnecting = false\n        reject(error)\n      }\n    })\n  }\n\n  private scheduleReconnect() {\n    if (this.reconnectTimer) {\n      clearTimeout(this.reconnectTimer)\n    }\n\n    const delay = this.reconnectDelays[Math.min(this.reconnectAttempts, this.reconnectDelays.length - 1)]\n    console.log(`[WS] Scheduling reconnect in ${delay}ms (attempt ${this.reconnectAttempts + 1}/${this.maxReconnectAttempts})`)\n\n    this.reconnectTimer = setTimeout(() => {\n      this.reconnectAttempts++\n      this.connect().catch(error => {\n        console.error('[WS] Reconnect failed:', error)\n      })\n    }, delay)\n  }\n\n  disconnect() {\n    this.shouldReconnect = false\n    if (this.reconnectTimer) {\n      clearTimeout(this.reconnectTimer)\n      this.reconnectTimer = null\n    }\n    if (this.ws) {\n      this.ws.close(1000, 'Client disconnect')\n      this.ws = null\n    }\n  }\n\n  on(eventType: WSEventType, listener: WSEventListener) {\n    if (!this.listeners.has(eventType)) {\n      this.listeners.set(eventType, new Set())\n    }\n    this.listeners.get(eventType)!.add(listener)\n  }\n\n  off(eventType: WSEventType, listener: WSEventListener) {\n    const listeners = this.listeners.get(eventType)\n    if (listeners) {\n      listeners.delete(listener)\n      if (listeners.size === 0) {\n        this.listeners.delete(eventType)\n      }\n    }\n  }\n\n  private emit(eventType: WSEventType, event: WSEvent) {\n    const listeners = this.listeners.get(eventType)\n    if (listeners) {\n      listeners.forEach(listener => {\n        try {\n          listener(event)\n        } catch (error) {\n          console.error(`[WS] Error in event listener for ${eventType}:`, error)\n        }\n      })\n    }\n  }\n\n  get isConnected(): boolean {\n    return this.ws?.readyState === WebSocket.OPEN\n  }\n\n  get connectionState(): string {\n    if (!this.ws) return 'disconnected'\n    switch (this.ws.readyState) {\n      case WebSocket.CONNECTING: return 'connecting'\n      case WebSocket.OPEN: return 'connected'\n      case WebSocket.CLOSING: return 'closing'\n      case WebSocket.CLOSED: return 'closed'\n      default: return 'unknown'\n    }\n  }\n}\n\n// Export a singleton instance\nexport const wsClient = new WSClient()\n\n// Auto-connect when module loads\nwsClient.connect().catch(error => {\n  console.warn('[WS] Initial connection failed, will retry:', error.message)\n})\n\nexport default wsClient"],"names":["WSClient","url","__publicField","WS_URL","resolve","reject","event","wsEvent","error","delay","eventType","listener","listeners","_a","wsClient"],"mappings":"gNAYA,MAAMA,CAAS,CAWb,YAAYC,EAAc,CAVlBC,EAAA,UAAuB,MACvBA,EAAA,YACAA,EAAA,qBAAgB,KAChBA,EAAA,yBAAoB,GACpBA,EAAA,4BAAuB,GACvBA,EAAA,uBAAkB,CAAC,IAAM,IAAM,IAAM,IAAO,GAAK,GACjDA,EAAA,sBAAuD,MACvDA,EAAA,oBAAe,IACfA,EAAA,uBAAkB,IAGxB,KAAK,IAAMD,GAAOE,CACpB,CAEA,SAAyB,CACnB,OAAA,KAAK,cAAiB,KAAK,IAAM,KAAK,GAAG,aAAe,UAAU,KAC7D,QAAQ,WAGjB,KAAK,aAAe,GACpB,KAAK,gBAAkB,GAEhB,IAAI,QAAQ,CAACC,EAASC,IAAW,CAClC,GAAA,CACF,KAAK,GAAK,IAAI,UAAU,KAAK,GAAG,EAE3B,KAAA,GAAG,OAAS,IAAM,CACrB,QAAQ,IAAI,oCAAoC,EAChD,KAAK,aAAe,GACpB,KAAK,kBAAoB,EACrB,KAAK,iBACP,aAAa,KAAK,cAAc,EAChC,KAAK,eAAiB,MAEhBD,GAAA,EAGL,KAAA,GAAG,UAAaE,GAAU,CACzB,GAAA,CACF,MAAMC,EAAmB,KAAK,MAAMD,EAAM,IAAI,EACzC,KAAA,KAAKC,EAAQ,KAAMA,CAAO,QACxBC,EAAO,CACN,QAAA,MAAM,gCAAiCA,CAAK,CACtD,CAAA,EAGG,KAAA,GAAG,QAAWA,GAAU,CACnB,QAAA,MAAM,wBAAyBA,CAAK,EAC5C,KAAK,aAAe,GAChB,KAAK,oBAAsB,GACtBH,EAAA,IAAI,MAAM,uCAAuC,CAAC,CAC3D,EAGG,KAAA,GAAG,QAAWC,GAAU,CAC3B,QAAQ,IAAI,2BAA2BA,EAAM,IAAI,IAAIA,EAAM,MAAM,EAAE,EACnE,KAAK,aAAe,GACpB,KAAK,GAAK,KAEN,KAAK,iBAAmB,KAAK,kBAAoB,KAAK,sBACxD,KAAK,kBAAkB,CACzB,QAEKE,EAAO,CACd,KAAK,aAAe,GACpBH,EAAOG,CAAK,CACd,CAAA,CACD,EACH,CAEQ,mBAAoB,CACtB,KAAK,gBACP,aAAa,KAAK,cAAc,EAG5B,MAAAC,EAAQ,KAAK,gBAAgB,KAAK,IAAI,KAAK,kBAAmB,KAAK,gBAAgB,OAAS,CAAC,CAAC,EAC5F,QAAA,IAAI,gCAAgCA,CAAK,eAAe,KAAK,kBAAoB,CAAC,IAAI,KAAK,oBAAoB,GAAG,EAErH,KAAA,eAAiB,WAAW,IAAM,CAChC,KAAA,oBACA,KAAA,QAAA,EAAU,MAAeD,GAAA,CACpB,QAAA,MAAM,yBAA0BA,CAAK,CAAA,CAC9C,GACAC,CAAK,CACV,CAEA,YAAa,CACX,KAAK,gBAAkB,GACnB,KAAK,iBACP,aAAa,KAAK,cAAc,EAChC,KAAK,eAAiB,MAEpB,KAAK,KACF,KAAA,GAAG,MAAM,IAAM,mBAAmB,EACvC,KAAK,GAAK,KAEd,CAEA,GAAGC,EAAwBC,EAA2B,CAC/C,KAAK,UAAU,IAAID,CAAS,GAC/B,KAAK,UAAU,IAAIA,EAAW,IAAI,GAAK,EAEzC,KAAK,UAAU,IAAIA,CAAS,EAAG,IAAIC,CAAQ,CAC7C,CAEA,IAAID,EAAwBC,EAA2B,CACrD,MAAMC,EAAY,KAAK,UAAU,IAAIF,CAAS,EAC1CE,IACFA,EAAU,OAAOD,CAAQ,EACrBC,EAAU,OAAS,GAChB,KAAA,UAAU,OAAOF,CAAS,EAGrC,CAEQ,KAAKA,EAAwBJ,EAAgB,CACnD,MAAMM,EAAY,KAAK,UAAU,IAAIF,CAAS,EAC1CE,GACFA,EAAU,QAAoBD,GAAA,CACxB,GAAA,CACFA,EAASL,CAAK,QACPE,EAAO,CACd,QAAQ,MAAM,oCAAoCE,CAAS,IAAKF,CAAK,CACvE,CAAA,CACD,CAEL,CAEA,IAAI,aAAuB,OAClB,QAAAK,EAAA,KAAK,KAAL,YAAAA,EAAS,cAAe,UAAU,IAC3C,CAEA,IAAI,iBAA0B,CAC5B,GAAI,CAAC,KAAK,GAAW,MAAA,eACb,OAAA,KAAK,GAAG,WAAY,CAC1B,KAAK,UAAU,WAAmB,MAAA,aAClC,KAAK,UAAU,KAAa,MAAA,YAC5B,KAAK,UAAU,QAAgB,MAAA,UAC/B,KAAK,UAAU,OAAe,MAAA,SAC9B,QAAgB,MAAA,SAClB,CACF,CACF,CAGa,MAAAC,EAAW,IAAId,EAG5Bc,EAAS,QAAU,EAAA,MAAeN,GAAA,CACxB,QAAA,KAAK,8CAA+CA,EAAM,OAAO,CAC3E,CAAC"}